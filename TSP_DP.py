import time

t = []
N = 16
W = [[0, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80],
     [5, 0, 9, 10, 18, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71],
     [6, 13, 0, 12, 19, 22, 27, 32, 37, 42, 47, 52, 57, 62, 67, 72],
     [8, 8, 9, 0, 17, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70],
     [14, 18, 19, 17, 0, 13, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69],
     [21, 21, 22, 20, 13, 0, 11, 16, 23, 28, 33, 38, 43, 48, 53, 58],
     [26, 26, 27, 25, 11, 11, 0, 5, 12, 17, 24, 29, 34, 39, 44, 49],
     [31, 31, 32, 30, 16, 5, 0, 4, 9, 14, 21, 26, 31, 36, 41, 46],
     [36, 36, 37, 35, 23, 12, 4, 0, 7, 12, 19, 24, 29, 34, 39, 44],
     [41, 41, 42, 40, 28, 17, 9, 7, 0, 5, 10, 17, 22, 27, 32, 37],
     [46, 46, 47, 45, 33, 24, 19, 12, 5, 0, 3, 8, 13, 18, 23, 28],
     [51, 51, 52, 50, 38, 29, 21, 16, 10, 3, 0, 2, 7, 12, 17, 22],
     [56, 56, 57, 55, 43, 34, 26, 21, 15, 8, 2, 0, 5, 10, 15, 20],
     [61, 61, 62, 60, 48, 39, 31, 26, 20, 13, 7, 2, 0, 3, 8, 13],
     [66, 66, 67, 65, 53, 44, 36, 31, 25, 18, 12, 7, 3, 0, 2, 7],
     [71, 71, 72, 70, 58, 51, 43, 38, 32, 25, 19, 14, 10, 5, 2, 0]]

for i in range(10):
    start = time.time()  # 시작 시간 저장

    dp = [[0 for _ in range(1 << N - 1)] for _ in range(N)]

    # 현재 위치 i, 지금까지 방문한 도시들의 집합 route일 때 최소 비용 구하는 함수
    def solution(i, route):
        global N, W, dp

        # 이미 방문한 경로면 memoization 해둔 값이므로 return
        if dp[i][route] != 0:
            return dp[i][route]

        # 모든 도시를 다 방문한 경우
        if route == (1 << (N - 1)) - 1:
            # 마지막 위치에서 0번 도시로 가는 경로가 없는 경우
            if not W[i][0]:
                return float('inf')
            # 마지막 위치에서 0번 도시로 가는 경로가 있는 경우 정답 반환
            else:
                return W[i][0]

        # 점화식을 토대로, 최소값을 찾아서 다음 방문 도시 선택하기
        min_price = float('inf')
        for j in range(1, N):
            # i번째 도시에서 j번째 도시로 가는 경로가 없는 경우
            if not W[i][j]:
                continue
            # j번째 도시가 이미 방문한 도시인 경우
            if route & (1 << j - 1):
                continue
            # j번째 도시를 방문했을 경우 비용 계산해서 최소값이면 선택
            # i -> j 도시 가는 비용 + solution(j번째 도시, j번째 도시를 추가한 경로)
            dist = W[i][j] + solution(j, route | (1 << (j - 1)))
            if min_price > dist:
                min_price = dist
        dp[i][route] = min_price
        return min_price

    t.append(time.time() - start)  # 현재시각 - 시작시간 = 실행 시간


print(solution(0, 0))
print("DP 평균 실행시간: ", sum(t)/len(t))
